/*
 * ImageDialog.java
 *
 * Created on December 14, 2000, 5:11 PM
 */

package imageproc;

/**
 *
 * @author  Karl A. Gossett
 * @version
 */


import java.awt.*;
import java.awt.image.*;
import java.awt.color.*;
import java.awt.image.renderable.ParameterBlock;

import javax.media.jai.*;

import imageproc.utilities.*;
import imageproc.utilities.Constants;

public class ImageDialog extends javax.swing.JDialog {
    
    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	BufferedImage crystal;
    BufferedImage origCrystal;    // Save original image for classification
    DisplayJAI imagePanel;
    Classifier classifier;
    
    boolean thresholding = false;
    
    ImageStatistics imageStatistics;
    
    boolean classified = false;
    
    static KernelJAI FREI_CHEN_KERNEL_HORIZONTAL =
    new KernelJAI (3,3,new float[] {1.0F,   0.0F, -1.0F,
    1.414F, 0.0F, -1.414F,
    1.0F,   0.0F, -1.0F});
    static KernelJAI FREI_CHEN_KERNEL_VERTICAL =
    new KernelJAI (3,3,new float[] {-1.0F, -1.414F, -1.0F,
    0.0F,  0.0F,    0.0F,
    1.0F,  1.414F,  1.0F});
    
    /** Creates new form ImageDialog */
    public ImageDialog (java.awt.Frame parent, boolean modal) {
        super (parent, modal);
        initComponents ();
        pack ();
        //crystal = new BufferedImage(640,480,BufferedImage.TYPE_BYTE_BINARY);
        //origCrystal = new BufferedImage(640,480,BufferedImage.TYPE_BYTE_BINARY);
        classifier = new Classifier();
        imageStatistics = new ImageStatistics ();
    }
    
    /** Constructor with image */
    public ImageDialog (java.awt.Frame parent, boolean modal, BufferedImage ci) {
        this (parent,modal);
        
        crystal = ci;
        origCrystal = ci;
        imagePanel = new DisplayJAI (crystal);
        imagePanel.setPreferredSize (new java.awt.Dimension (640, 480));
        imagePanel.setMinimumSize (new java.awt.Dimension (640,480));
        getContentPane ().add(imagePanel);
        this.setVisible(true);
    }
    
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the FormEditor.
     */
    private void initComponents () {//GEN-BEGIN:initComponents
        parameterPanel = new javax.swing.JPanel ();
        thresholdText = new javax.swing.JLabel ();
        thresholdLevel = new javax.swing.JTextField ();
        clusterText = new javax.swing.JLabel ();
        useThresholding = new javax.swing.JCheckBox ();
        clusterCount = new javax.swing.JTextField ();
        useEdgeDetect = new javax.swing.JCheckBox ();
        showGrid = new javax.swing.JCheckBox ();
        showClustering = new javax.swing.JCheckBox ();
        buttonPanel = new javax.swing.JPanel ();
        resetImage = new javax.swing.JButton ();
        setName ("imageDialog");
        setTitle ("Image");
        addWindowListener (new java.awt.event.WindowAdapter () {
            public void windowClosing (java.awt.event.WindowEvent evt) {
                closeDialog (evt);
            }
        }
        );
        
        parameterPanel.setLayout (new java.awt.GridBagLayout ());
        java.awt.GridBagConstraints gridBagConstraints1;
        parameterPanel.setPreferredSize (new java.awt.Dimension (249, 91));
        parameterPanel.setBorder (new javax.swing.border.TitledBorder ("Parameters"));
        parameterPanel.setMinimumSize (new java.awt.Dimension (249, 91));
        
        thresholdText.setText ("Thresholding Level");
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 3;
          gridBagConstraints1.gridy = 0;
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.EAST;
          parameterPanel.add (thresholdText, gridBagConstraints1);
          
          
        thresholdLevel.setPreferredSize (new java.awt.Dimension (40, 20));
          thresholdLevel.setToolTipText ("Threshold to Accept as an Edge (0-255)");
          thresholdLevel.setText ("28");
          thresholdLevel.setMinimumSize (new java.awt.Dimension (40, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 4;
          gridBagConstraints1.gridy = 0;
          gridBagConstraints1.insets = new java.awt.Insets (0, 5, 0, 0);
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (thresholdLevel, gridBagConstraints1);
          
          
        clusterText.setText ("Clusters");
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 3;
          gridBagConstraints1.gridy = 1;
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.EAST;
          parameterPanel.add (clusterText, gridBagConstraints1);
          
          
        useThresholding.setPreferredSize (new java.awt.Dimension (110, 20));
          useThresholding.setToolTipText ("Turn Thresholding On/Off");
          useThresholding.setMaximumSize (new java.awt.Dimension (110, 20));
          useThresholding.setText ("Threshold");
          useThresholding.setMinimumSize (new java.awt.Dimension (110, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 2;
          gridBagConstraints1.gridy = 1;
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (useThresholding, gridBagConstraints1);
          
          
        clusterCount.setPreferredSize (new java.awt.Dimension (40, 20));
          clusterCount.setMaximumSize (new java.awt.Dimension (40, 20));
          clusterCount.setText ("4");
          clusterCount.setMinimumSize (new java.awt.Dimension (40, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 4;
          gridBagConstraints1.gridy = 1;
          gridBagConstraints1.insets = new java.awt.Insets (0, 5, 0, 0);
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (clusterCount, gridBagConstraints1);
          
          
        useEdgeDetect.setPreferredSize (new java.awt.Dimension (110, 20));
          useEdgeDetect.setText ("Detect Edges");
          useEdgeDetect.setMinimumSize (new java.awt.Dimension (89, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 2;
          gridBagConstraints1.gridy = 0;
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (useEdgeDetect, gridBagConstraints1);
          
        showGrid.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
                if (imagePanel!=null) {
                	imagePanel.setDrawGrid(showGrid.isSelected());
                	imagePanel.repaint();
                }
            }
        }
        );  
        showGrid.setPreferredSize (new java.awt.Dimension (110, 20));
          showGrid.setText ("Show Grid");
          showGrid.setMinimumSize (new java.awt.Dimension (105, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 0;
          gridBagConstraints1.gridy = 0;
          gridBagConstraints1.insets = new java.awt.Insets (0, 0, 0, 10);
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (showGrid, gridBagConstraints1);
          
          
        showClustering.setPreferredSize (new java.awt.Dimension (110, 20));
          showClustering.setText ("Show Clustering");
          showClustering.setMinimumSize (new java.awt.Dimension (105, 20));
          gridBagConstraints1 = new java.awt.GridBagConstraints ();
          gridBagConstraints1.gridx = 0;
          gridBagConstraints1.gridy = 1;
          gridBagConstraints1.insets = new java.awt.Insets (0, 0, 0, 10);
          gridBagConstraints1.anchor = java.awt.GridBagConstraints.WEST;
          parameterPanel.add (showClustering, gridBagConstraints1);
          
          
        getContentPane ().add (parameterPanel, java.awt.BorderLayout.NORTH);
        
        
        
        resetImage.setText ("Reset Image");
          resetImage.addActionListener (new java.awt.event.ActionListener () {
              public void actionPerformed (java.awt.event.ActionEvent evt) {
                  resetImageActionPerformed (evt);
              }
          }
          );
          buttonPanel.add (resetImage);
          
          
        getContentPane ().add (buttonPanel, java.awt.BorderLayout.SOUTH);
        
    }//GEN-END:initComponents
    
  private void resetImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetImageActionPerformed
      // Add your handling code here:
      resetImage ();
  }//GEN-LAST:event_resetImageActionPerformed
  
    /** Closes the dialog */
    private void closeDialog(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closeDialog
        setVisible (false);
        dispose ();
    }//GEN-LAST:event_closeDialog
    
    /**
     * @param args the command line arguments
     */
    public static void main (String args[]) {
        new ImageDialog (new javax.swing.JFrame (), true).setVisible (true);
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel parameterPanel;
    private javax.swing.JLabel thresholdText;
    private javax.swing.JTextField thresholdLevel;
    private javax.swing.JLabel clusterText;
    private javax.swing.JCheckBox useThresholding;
    private javax.swing.JTextField clusterCount;
    private javax.swing.JCheckBox useEdgeDetect;
    private javax.swing.JCheckBox showGrid;
    private javax.swing.JCheckBox showClustering;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JButton resetImage;
    // End of variables declaration//GEN-END:variables
    
    /**
     * Sets the image in this image dialog.
     */
    public void setImage (BufferedImage i) {
        crystal = i;
        origCrystal = i;
        if (imagePanel == null) {
            imagePanel = new DisplayJAI (crystal);
            getContentPane ().add(imagePanel);
        } else {
            imagePanel.set(crystal);
        }
        classified = false;
    }
    
    /**
     * Reset the image in this dialog to the unprocessed image
     */
    public void resetImage () {
        crystal = origCrystal;
        imagePanel.set(crystal);
        classified = false;
    }
            
    /** method imageProcess performs all processing steps on an image.
     * 1.  Detect Edges
     * 2.  Perform Thresholding
     * 3.  Extract features (display grid)
     */
    public void processAll (boolean singleProcess) {

        if (useEdgeDetect.isSelected ()) detectEdges ();
        if (useThresholding.isSelected ()) threshold ();
        // If not processing for datafile, just draw a grid and display it,
        // Otherwise grab pixels for processing.
        imageStatistics.calculateStats (crystal, origCrystal, Constants.rect);
        if (singleProcess) {
            getGridImage ();
            imagePanel.set (crystal);
        }
    }
    
    /**
     * Method to detect edges in the image.  Uses JAI gradientmagnitude
     * operation using Frei-Chen kernels.
     *
     * @see javax.media.jai.JAI
     */
    protected void detectEdges () {
        
        crystal = JAI.create ("gradientmagnitude",
                              crystal,
                              FREI_CHEN_KERNEL_HORIZONTAL,
                              FREI_CHEN_KERNEL_VERTICAL).getAsBufferedImage ();
        imagePanel.set(crystal);
    }
    
    /**
     * Threshold the edges on the image.  All pixels below the specified
     * intensity will be thresholded to 0 (black).
     */
    public void threshold () {
        int tl = Integer.valueOf(thresholdLevel.getText()).intValue();
        if ((tl >= 0) && (tl < 256)) {
            thresholder (0.0d, tl, 0.0d);
            //        thresholder (tl, 256.0d, 255.0d);
        }
        else thresholdLevel.setText("128");
    }
    
    /**
     * Method to perform thresholding.  Thresholds pixels between
     * the specified low & high, setting them to the target value.
     *
     * @param lowValue          The darkest pixel to threshold (0-255)
     * @param highValue         The lightest pixel to threshold (lowValue-255)
     * @param target            The target intensity (0-255)
     */
    private void thresholder (double lowValue, double highValue, double target) {
        double[] low;   // Bottom boundary for threshold
        double[] high;  // Top boundary for threshold
        double[] map;  // Mapping to use when thresholding
        
        low = new double[1];
        high = new double[1];
        map = new double[1];
        
        // Set boundaries for threshold.
        if (lowValue > highValue) lowValue = highValue; // No thresholding
        low[0] = lowValue;
        high[0] = highValue;
        map[0] = target;
        
        // Create the parameter block
        ParameterBlock pb = new ParameterBlock ();
        pb.addSource (crystal);
        pb.add (low);
        pb.add (high);
        pb.add (map);
        
        // Perform the thresholding
        crystal = JAI.create ("threshold",pb,null).getAsBufferedImage ();
        imagePanel.set(crystal);
    }
    
    /**
     * Create a rectangular grid over the image.
     */
    public void getGridImage() {
        if (showClustering.isSelected ()) showClusters ();
    }
    
    /** Return the statistics of this image */
    public ImageStatistics getStatistics () {
        return imageStatistics;
    }
  
    private void classifyImage () {
        CrystalClassifier.myLog.config (getClassification());
    }
    
    public String getClassification () {
        double[] edgeMean = imageStatistics.getRegionEdgeMeans ();
        double[] edgeMax = imageStatistics.getRegionEdgeMax ();
        double[] originalMean = imageStatistics.getUnprocessedMeans ();
        double[] originalMin = imageStatistics.getUnprocessedRegionMins ();
        double[] originalStdev = imageStatistics.getUnprocessedRegionStdev ();
        classifier.classifyRegions (edgeMean, edgeMax, originalMean, 
                                    originalMin, originalStdev);
        classifier.classify ();
        classified = true;
        return (classifier.classificationResults());
    }
    
    public String getClassifyNarrative() {
        if (!classified) {
            getClassification();  // Just dispose of the returned string
        }
        return (classifier.classificationNarrative());
    }
    
    public String getClassExpectations () {
        if (!classified) {
            double[] edgeMean = imageStatistics.getRegionEdgeMeans ();
            double[] edgeMax = imageStatistics.getRegionEdgeMax ();
            double[] originalMean = imageStatistics.getUnprocessedMeans ();
            double[] originalMin = imageStatistics.getUnprocessedRegionMins ();
            double[] originalStdev = imageStatistics.getUnprocessedRegionStdev ();
            classifier.classifyRegions (edgeMean, edgeMax, originalMean, 
                                        originalMin, originalStdev);
            classifier.classify ();
        }
        return classifier.classExpectations();
    }
    
    public String getFrequencies() {
        return classifier.classFrequencies();
    }
    
    public void showClusters () {
        
        classifyImage ();
        int[] classes = classifier.getRegionClasses();
        Point[] classCenter = classifier.getClassCenters ();        

        BufferedImage ci = new BufferedImage(640,480,BufferedImage.TYPE_INT_RGB);
        ColorConvertOp co = new ColorConvertOp(ColorSpace.getInstance(ColorSpace.CS_sRGB),null);
        co.filter(crystal, ci);
        crystal = ci;
        Graphics2D g2 = crystal.createGraphics();
        
        int q=0;
        for (int x = 0; x < Constants.REGIONS_HORIZ - 1; x++) {
            for (int y = 0; y < Constants.REGIONS_VERTICAL; y++) {                
                switch (classes[q]) {
                    case 0 : 
                        g2.setColor(Color.blue);
                        break;
                    case 1 : 
                        g2.setColor(Color.green);
                        break;
                    case 2 : 
                        g2.setColor(Color.white);
                        break;
                    case 3 : 
                        g2.setColor(Color.red);
                        break;
                    
                }
                // Show based on decision tree rules
                if (classes[q] != Constants.class_clear) {
                    g2.fillRect(x*Constants.REGION_SIZE+6,
                                y*Constants.REGION_SIZE+6,
                                Constants.REGION_SIZE-12,
                                Constants.REGION_SIZE-12);
                }
                q++;
            }
        }
        
        Point[] stdev = classifier.getComponentStdev ();
        double[] singleStdev = classifier.getCenterStdev();
        Point avgCenter = new Point ();
        //double avgStdev = 0.0d;
        avgCenter.setLocation((classCenter[1].getX() + classCenter[2].getX() 
                            + classCenter[3].getX())/3, (classCenter[1].getY()
                            + classCenter[2].getY() + classCenter[3].getY())/3);
        double avgStdevX = (stdev[1].getX() + stdev[2].getX() 
                            + stdev[3].getX()) /3;
        double avgStdevY = (stdev[1].getY() + stdev[2].getY() 
                            + stdev[3].getY()) /3;
        g2.setColor (Color.cyan);
        g2.drawOval((int)Math.round(avgCenter.getX())+3,
            (int)Math.round(avgCenter.getY())+3,10,10);
        g2.drawOval((int)Math.round(avgCenter.getX()-avgStdevX*2+8),
                    (int)Math.round(avgCenter.getY()-avgStdevY*2+8),
                    (int)avgStdevX*4,(int)avgStdevY*4);
            
        for (int k = 0; k < Constants.NUMBER_OF_CLASSES; k++) {
            switch (k) {
                case Constants.class_edge : 
                    g2.setColor(Color.white);
                    break;
                case Constants.class_precip : 
                    g2.setColor(Color.green);
                    break;
                case Constants.class_crystal : 
                    g2.setColor(Color.red);
                    break;
                case Constants.class_clear : 
                    g2.setColor(Color.blue);
                    break;
            }
            g2.drawOval((int)Math.round(classCenter[k].getX())+3,
            (int)Math.round(classCenter[k].getY())+3,10,10);
            g2.drawOval((int)Math.round(classCenter[k].getX())+4,
            (int)Math.round(classCenter[k].getY())+4,8,8);
            
            g2.drawOval((int)Math.round(classCenter[k].getX()-singleStdev[k]+8),
                        (int)Math.round(classCenter[k].getY()-singleStdev[k]+8),
                        (int)(singleStdev[k]*2),(int)(singleStdev[k]*2));
            
            g2.drawOval((int)Math.round(classCenter[k].getX()-stdev[k].getX()+8),
                        (int)Math.round(classCenter[k].getY()-stdev[k].getY()+8),
                        (int)stdev[k].getX()*2,(int)stdev[k].getY()*2);   
        }
        imagePanel.set(crystal);
    } // End showClusters
    
    /* (non-Javadoc)
	 * @see java.awt.Container#paint(java.awt.Graphics)
	 */
	public void paint(Graphics g) {
		super.paint(g);
	}

}